[
  {
    "objectID": "Take-home Exercise/Take-home_Ex2/Take-home_Ex2.html#packages-used",
    "href": "Take-home Exercise/Take-home_Ex2/Take-home_Ex2.html#packages-used",
    "title": "ISSS624",
    "section": "3.1 Packages used",
    "text": "3.1 Packages used\nBefore we get started, it is important for us to install the necessary R packages into R and launch these R packages into R environment.\nThe R packages needed for this exercise are as follows:\n\nSpatial data handling\n\nsf, rgdal and spdep\n\nAttribute data handling\n\ntidyverse, especially readr, ggplot2 and dplyr\n\nChoropleth mapping\n\ntmap\n\nMultivariate data visualisation and analysis\n\ncoorplot, ggpubr, GGally, hrbrthemes and heatmaply\n\nCluster analysis\n\ncluster\nClustGeo\n\nExploratory Data Analysis\n\nfunModeling\n\n\n\npacman::p_load(rgdal, spdep, tmap, sf, ClustGeo, \n               ggpubr, cluster, factoextra, NbClust,\n               heatmaply, corrplot, psych, tidyverse, funModeling, GGally, hrbrthemes)"
  },
  {
    "objectID": "Take-home Exercise/Take-home_Ex2/Take-home_Ex2.html#importing-geospatial-data",
    "href": "Take-home Exercise/Take-home_Ex2/Take-home_Ex2.html#importing-geospatial-data",
    "title": "ISSS624",
    "section": "4.1 Importing Geospatial Data",
    "text": "4.1 Importing Geospatial Data\nIn this in-class data, aspatial and geospatial data sets will be used, they are:\ngeo_export_11f67af6-d430-41fc-b181-fa36b07ee920\ngeoBoundaries-NGA-ADM2\n\n4.1.1 Importing water point geospatial data\nFirst, we are going to import the water point geospatial data (i.e. geo_export) by using the code chunk below.\n\nwp <- st_read(dsn = \"data/aspatial/\",\n               layer = \"geo_export_1897fdeb-cbff-40b2-9f5f-4732e607388a\",crs = 4326) %>%\n  filter(clean_coun == \"Nigeria\")\n\nReading layer `geo_export_1897fdeb-cbff-40b2-9f5f-4732e607388a' from data source `C:\\meizhutao\\ISSS624\\Take-home Exercise\\Take-home_Ex2\\data\\aspatial' \n  using driver `ESRI Shapefile'\n\n\nWarning: st_crs<- : replacing crs does not reproject data; use st_transform for\nthat\n\n\nSimple feature collection with 406566 features and 72 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -92.05073 ymin: -27.31495 xmax: 92.32694 ymax: 26.65622\nGeodetic CRS:  WGS 84\n\n\nWe can retrieve the geometry list-column in this case by using st_geometry() as shown in the code chunk below.\n\nst_geometry(wp)\n\nGeometry set for 95008 features \nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 2.707441 ymin: 4.301812 xmax: 14.21828 ymax: 13.86568\nGeodetic CRS:  WGS 84\nFirst 5 geometries:\n\n\nPOINT (5.12 7.98)\n\n\nPOINT (3.597668 6.964532)\n\n\nPOINT (7.92972 6.48694)\n\n\nPOINT (7.64867 6.72757)\n\n\nPOINT (7.66485 6.7799)\n\n\nWe will then use the st_as_sf() function to convert the dataframe to an sf object. We will have to input the column that specify the longitude and latitude, and lastly, the CRS projection of the coordinates.\n\nwp <- st_as_sf(wp, coords = c(\"lon_deg\", \"lat_deg\"),  crs = 4326)\nst_crs(wp)\n\nCoordinate Reference System:\n  User input: EPSG:4326 \n  wkt:\nGEOGCRS[\"WGS 84\",\n    DATUM[\"World Geodetic System 1984\",\n        ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n            LENGTHUNIT[\"metre\",1]]],\n    PRIMEM[\"Greenwich\",0,\n        ANGLEUNIT[\"degree\",0.0174532925199433]],\n    CS[ellipsoidal,2],\n        AXIS[\"geodetic latitude (Lat)\",north,\n            ORDER[1],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        AXIS[\"geodetic longitude (Lon)\",east,\n            ORDER[2],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n    USAGE[\n        SCOPE[\"Horizontal component of 3D system.\"],\n        AREA[\"World.\"],\n        BBOX[-90,-180,90,180]],\n    ID[\"EPSG\",4326]]\n\n#wp <- st_transform (wp, crs = 26391)\n\n\n\n4.1.2 Importing Nigeria LGA boundary data\nNow, we are going to import the LGA boundary data into R environment by using the code chunk below.\n\nnga <- st_read(dsn = \"data/geospatial\",layer = \"geoBoundaries-NGA-ADM2\", crs = 4326) %>%\n  select(shapeName)\n\nReading layer `geoBoundaries-NGA-ADM2' from data source \n  `C:\\meizhutao\\ISSS624\\Take-home Exercise\\Take-home_Ex2\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 774 features and 5 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2.668534 ymin: 4.273007 xmax: 14.67882 ymax: 13.89442\nGeodetic CRS:  WGS 84\n\nst_crs(nga)\n\nCoordinate Reference System:\n  User input: EPSG:4326 \n  wkt:\nGEOGCRS[\"WGS 84\",\n    DATUM[\"World Geodetic System 1984\",\n        ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n            LENGTHUNIT[\"metre\",1]]],\n    PRIMEM[\"Greenwich\",0,\n        ANGLEUNIT[\"degree\",0.0174532925199433]],\n    CS[ellipsoidal,2],\n        AXIS[\"geodetic latitude (Lat)\",north,\n            ORDER[1],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        AXIS[\"geodetic longitude (Lon)\",east,\n            ORDER[2],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n    USAGE[\n        SCOPE[\"Horizontal component of 3D system.\"],\n        AREA[\"World.\"],\n        BBOX[-90,-180,90,180]],\n    ID[\"EPSG\",4326]]\n\n\n\nst_geometry(nga)\n\nGeometry set for 774 features \nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2.668534 ymin: 4.273007 xmax: 14.67882 ymax: 13.89442\nGeodetic CRS:  WGS 84\nFirst 5 geometries:\n\n\nMULTIPOLYGON (((7.401109 5.081948, 7.400133 5.0...\n\n\nMULTIPOLYGON (((7.334479 5.104902, 7.335673 5.1...\n\n\nMULTIPOLYGON (((13.83477 13.42336, 13.81909 13....\n\n\nMULTIPOLYGON (((7.045872 9.230501, 7.026536 9.2...\n\n\nMULTIPOLYGON (((7.811244 5.094527, 7.812334 5.0...\n\n\nNext, write_rds() of readr package is used to save the extracted sf data table (i.e. wp) into an output file in rds data format. The output file is called wp_nga.rds and it is saved in geodata sub-folder.\n\nwrite_rds(nga, \"data/geospatial/wp_nga.rds\")"
  },
  {
    "objectID": "Take-home Exercise/Take-home_Ex2/Take-home_Ex2.html#data-wrangling",
    "href": "Take-home Exercise/Take-home_Ex2/Take-home_Ex2.html#data-wrangling",
    "title": "ISSS624",
    "section": "4.2 Data Wrangling",
    "text": "4.2 Data Wrangling\n\n4.2.1 Recoding NA values into string\nIn the code chunk below, replace_na() is used to recode all the NA values in status_cle field into Unknown.\n\n\n4.2.2 EDA\nChecking of duplicated shapeName. We will then use the duplicated function to retrieve all the shapeName that has duplicates and store it in a list.\n\nduplicated_area <- nga %>% \n  mutate(dup_shapeName = duplicated(shapeName)) %>% \n  filter(dup_shapeName)\nduplicated_area$shapeName\n\n[1] \"Bassa\"    \"Ifelodun\" \"Irepodun\" \"Nasarawa\" \"Obi\"      \"Surulere\"\n\n\nIndex shapeName 94 Bassa (Kogi) 95 Bassa (Plateau) 304 Ifelodun (Kwara) 305 Ifelodun (Osun) 355 Irepodun (Kwara) 356 Irepodun (Osun) 518 Nassarawa 546 Obi (Benue) 547 Obi(Nasarawa) 693 Surulere (lagos) 694 Surulere (Oyo)\nWe will access the index of the nga data frame and assign correct shapeName.\n\nnga$shapeName[c(94,95,304,305,355,356,519,546,547,693,694)] <- c(\"bassa kogi\",\"bassa plateau\",\n                                                                               \"ifelodun kwara\",\"ifelodun osun\",\n                                                                               \"irepodun kwara\",\"irepodun osun\",\n                                                                               \"nassarawa\",\"obi benue\",\"obi nasarawa\",\n                                                                               \"surulere lagos\",\"surulere oyo\")\n\nCheck again whether still have duplicated shapeName.\n\nlength((nga$shapeName[ nga$shapeName %in% nga$shapeName[duplicated(nga$shapeName)] ]))\n\n[1] 0\n\n\nNo more duplicated shapeName.\nIn the code chunk below, freq() of funModeling package is used to display the distribution of status_cle field in wp_nga.\n\nwp_nga <- wp %>%\n  mutate(status_cle = replace_na(status_cle, \"Unknown\"))\n\nfreq(data=wp_nga, \n     input = 'status_cle')\n\nWarning: `guides(<scale> = FALSE)` is deprecated. Please use `guides(<scale> =\n\"none\")` instead.\n\n\n\n\n\n                        status_cle frequency percentage cumulative_perc\n1                       Functional     45883      48.29           48.29\n2                   Non-Functional     29385      30.93           79.22\n3                          Unknown     10656      11.22           90.44\n4      Functional but needs repair      4579       4.82           95.26\n5 Non-Functional due to dry season      2403       2.53           97.79\n6        Functional but not in use      1686       1.77           99.56\n7         Abandoned/Decommissioned       234       0.25           99.81\n8                        Abandoned       175       0.18           99.99\n9 Non functional due to dry season         7       0.01          100.00"
  },
  {
    "objectID": "Take-home Exercise/Take-home_Ex2/Take-home_Ex2.html#extracting-water-point-data",
    "href": "Take-home Exercise/Take-home_Ex2/Take-home_Ex2.html#extracting-water-point-data",
    "title": "ISSS624",
    "section": "4.3 Extracting Water Point Data",
    "text": "4.3 Extracting Water Point Data\n\n4.3.1 Extracting funtional water point\nIn the code chunk below, filter() of dplyr is used to select functional water points.\n\nwpt_functional <- wp_nga %>%\n  filter(status_cle %in%\n           c(\"Functional\", \n             \"Functional but not in use\",\n             \"Functional but needs repair\"))\n\n\nfreq(data=wpt_functional, \n     input = 'status_cle')\n\nWarning: `guides(<scale> = FALSE)` is deprecated. Please use `guides(<scale> =\n\"none\")` instead.\n\n\n\n\n\n                   status_cle frequency percentage cumulative_perc\n1                  Functional     45883      87.99           87.99\n2 Functional but needs repair      4579       8.78           96.77\n3   Functional but not in use      1686       3.23          100.00\n\n\n\n\n4.3.2 Extracting non-funtional water point\n\nwpt_nonfunctional <- wp_nga %>%\n  filter(status_cle %in%\n           c(\"Abandoned/Decommissioned\", \n             \"Abandoned\",\n             \"Non-Functional\",\n             \"Non functional due to dry season\",\n             \"Non-Functional due to dry season\"))\n\n\nfreq(data=wpt_nonfunctional, \n     input = 'status_cle')\n\nWarning: `guides(<scale> = FALSE)` is deprecated. Please use `guides(<scale> =\n\"none\")` instead.\n\n\n\n\n\n                        status_cle frequency percentage cumulative_perc\n1                   Non-Functional     29385      91.25           91.25\n2 Non-Functional due to dry season      2403       7.46           98.71\n3         Abandoned/Decommissioned       234       0.73           99.44\n4                        Abandoned       175       0.54           99.98\n5 Non functional due to dry season         7       0.02          100.00\n\n\n\n\n4.3.3 Extracting water point with Unknown class\n\nwpt_unknown <- wp_nga %>%\n  filter(status_cle == \"Unknown\")\n\n\n\n4.3.3 Extracting main water point technology\n\nfreq(data=wp_nga, \n     input = 'X_water_tec')\n\nWarning: `guides(<scale> = FALSE)` is deprecated. Please use `guides(<scale> =\n\"none\")` instead.\n\n\n\n\n\n      X_water_tec frequency percentage cumulative_perc\n1       Hand Pump     58755      61.84           61.84\n2 Mechanized Pump     25644      26.99           88.83\n3            <NA>     10055      10.58           99.41\n4        Tapstand       553       0.58           99.99\n5 Rope and Bucket         1       0.00          100.00\n\n\n\nwpt_handpump <- wp_nga%>%\n  filter(X_water_tec == \"Hand Pump\")\n\n\nwpt_mechanizedpump <- wp_nga%>%\n  filter(X_water_tec == \"Mechanized Pump\")\n\n\n\n4.3.3 Extracting usage capacity\n\nfreq(data=wp_nga, \n     input = 'usage_cap')\n\nWarning: `guides(<scale> = FALSE)` is deprecated. Please use `guides(<scale> =\n\"none\")` instead.\n\n\n\n\n\n  usage_cap frequency percentage cumulative_perc\n1       300     68789      72.40           72.40\n2      1000     25644      26.99           99.39\n3       250       573       0.60           99.99\n4        50         2       0.00          100.00\n\n\n\nwpt_usage_less_1000 <- wp_nga%>%\n  filter(usage_cap %in%\n           c(\"50\", \n             \"250\",\n             \"300\"))\n\n\nwpt_usage_more_1000 <- wp_nga%>%\n  filter(usage_cap == \"1000\")\n\n\n\n4.3.3 Extracting rural water points\n\nfreq(data=wp_nga, \n     input = 'is_urban')\n\nWarning: `guides(<scale> = FALSE)` is deprecated. Please use `guides(<scale> =\n\"none\")` instead.\n\n\n\n\n\n  is_urban frequency percentage cumulative_perc\n1    False     75444      79.41           79.41\n2     True     19564      20.59          100.00\n\n\n\nwpt_rural <- wp_nga%>%\n  filter(is_urban == \"False\")"
  },
  {
    "objectID": "Take-home Exercise/Take-home_Ex2/Take-home_Ex2.html#performing-point-in-polygon-count",
    "href": "Take-home Exercise/Take-home_Ex2/Take-home_Ex2.html#performing-point-in-polygon-count",
    "title": "ISSS624",
    "section": "4.4 Performing Point-in-Polygon Count",
    "text": "4.4 Performing Point-in-Polygon Count\n\nnga_wp <- nga %>% \n  mutate(`total wpt` = lengths(\n    st_intersects(nga, wp_nga))) %>%\n  mutate(`wpt functional` = lengths(\n    st_intersects(nga, wpt_functional))) %>%\n  mutate(`wpt non-functional` = lengths(\n    st_intersects(nga, wpt_nonfunctional))) %>%\n  mutate(`wpt unknown` = lengths(\n    st_intersects(nga, wpt_unknown)))%>%\n  mutate(`wpt handpump` = lengths(\n    st_intersects(nga, wpt_handpump)))%>%\n  mutate(`wpt mechanizedpump` = lengths(\n    st_intersects(nga, wpt_mechanizedpump)))%>%\n  mutate(`wpt usage less 1000` = lengths(\n    st_intersects(nga, wpt_usage_less_1000)))%>%\n  mutate(`wpt usage more 1000` = lengths(\n    st_intersects(nga, wpt_usage_more_1000)))%>%\n  mutate(`wpt rural` = lengths(\n    st_intersects(nga, wpt_rural)))"
  },
  {
    "objectID": "Take-home Exercise/Take-home_Ex2/Take-home_Ex2.html#saving-the-analytical-data-table",
    "href": "Take-home Exercise/Take-home_Ex2/Take-home_Ex2.html#saving-the-analytical-data-table",
    "title": "ISSS624",
    "section": "4.5 Saving the Analytical Data Table",
    "text": "4.5 Saving the Analytical Data Table\n\nnga_wp <- nga_wp %>%\n  mutate(pct_functional = `wpt functional`/`total wpt`)%>%\n  mutate(`pct_non-functional` = `wpt non-functional`/`total wpt`) %>%\n  mutate(`pct_handpump` = `wpt handpump`/`total wpt`) %>%\n  mutate(`pct_mechanizedpump` = `wpt mechanizedpump`/`total wpt`) %>%\n  mutate(`pct_usage_less_1000` = `wpt usage less 1000`/`total wpt`) %>%\n  mutate(`pct_usage_more_1000` = `wpt usage more 1000`/`total wpt`) %>%\n  mutate(`pct_rural` = `wpt rural`/`total wpt`) \n # select(1,6:9,16:22)\n\nThings to learn from the code chunk above:\nmutate() of dplyr package is used to derive two fields namely pct_functional and pct_non-functional. to keep the file size small, select() of dplyr is used to retain only field 1, 6 to 12.\nThe following code chunks is to covert NaN to “0”.\n\nnga_wp$pct_functional[is.nan(nga_wp$pct_functiona)]<-0\nnga_wp$`pct_non-functional`[is.nan(nga_wp$`pct_non-functional`)]<-0\nnga_wp$pct_handpump[is.nan(nga_wp$pct_handpump)]<-0\nnga_wp$`pct_mechanizedpump`[is.nan(nga_wp$`pct_mechanizedpump`)]<-0\nnga_wp$pct_usage_less_1000[is.nan(nga_wp$pct_usage_less_1000)]<-0\nnga_wp$`pct_usage_more_1000`[is.nan(nga_wp$`pct_usage_more_1000`)]<-0\nnga_wp$`pct_rural`[is.nan(nga_wp$`pct_rural`)]<-0\n\nNow, we have the tidy sf data table subsequent analysis. We will save the sf data table into rds format.\n\nwrite_rds(nga_wp, \"data/geospatial/nga_wp.rds\")\n\nWe will have two datasets, one is used to analyze functional water points, the other is used to analyze functional water points.\n\nnga_wp <- read_rds(\"data/geospatial/nga_wp.rds\") %>% \n  st_transform(crs = 26391)"
  },
  {
    "objectID": "Take-home Exercise/Take-home_Ex2/Take-home_Ex2.html#eda-using-statistical-graphics",
    "href": "Take-home Exercise/Take-home_Ex2/Take-home_Ex2.html#eda-using-statistical-graphics",
    "title": "ISSS624",
    "section": "5.1 EDA using statistical graphics",
    "text": "5.1 EDA using statistical graphics\n\ng1 <- ggplot(data=nga_wp, \n       aes(x=`wpt functional`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\ng2 <- ggplot(data=nga_wp, \n       aes(x=`wpt non-functional`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\ng3 <- ggplot(data=nga_wp, \n       aes(x=`pct_functional`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\ng4 <-ggplot(data=nga_wp, \n       aes(x=`pct_non-functional`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\ng5 <-ggplot(data=nga_wp, \n       aes(x=`pct_handpump`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\ng6 <-ggplot(data=nga_wp, \n       aes(x=`pct_mechanizedpump`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\ng7 <-ggplot(data=nga_wp, \n       aes(x=`pct_usage_less_1000`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\ng8 <-ggplot(data=nga_wp, \n       aes(x=`pct_usage_more_1000`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\ng9 <-ggplot(data=nga_wp, \n       aes(x=`pct_rural`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\nggarrange(g1,g2,g3,g4,g5,g6,g7,g8,g9, ncol=3, nrow=3)"
  },
  {
    "objectID": "Take-home Exercise/Take-home_Ex2/Take-home_Ex2.html#eda-using-choropleth-map",
    "href": "Take-home Exercise/Take-home_Ex2/Take-home_Ex2.html#eda-using-choropleth-map",
    "title": "ISSS624",
    "section": "5.2 EDA using choropleth map",
    "text": "5.2 EDA using choropleth map\n\n5.2.1 Preparing a choropleth map\n\nwp_functional <- qtm(nga_wp, \"wpt functional\")+\n  tm_layout(main.title = \"Distribution of functional water points\",\n            main.title.position = \"center\",\n            main.title.size = 0.5,\n            legend.height = 0.5, \n            legend.width = 0.4,\n            legend.text.size = 0.5,\n            legend.title.size = 0.5,\n            main.title.fontface = \"bold\",\n            frame = TRUE)\nwp_nonfunctional <- qtm(nga_wp, \"wpt non-functional\")+\n  tm_layout(main.title = \"Distribution of non-functional water points\",\n            main.title.position = \"center\",\n            main.title.size = 0.5,\n            legend.height = 0.5, \n            legend.width = 0.4,\n            legend.text.size = 0.5,\n            legend.title.size = 0.5,\n            main.title.fontface = \"bold\",\n            frame = TRUE)\npct_functional <- qtm(nga_wp, \"pct_functional\")+\n  tm_layout(main.title = \"Distribution of functional water points rate\",\n            main.title.position = \"center\",\n            main.title.size = 0.5,\n            legend.height = 0.5, \n            legend.width = 0.5,\n            legend.text.size = 0.5,\n            legend.title.size = 0.5,\n            main.title.fontface = \"bold\",\n            frame = TRUE)\npct_nonfunctional <- qtm(nga_wp, \"pct_non-functional\")+\n  tm_layout(main.title = \"Distribution of non-functional water points rate\",\n            main.title.position = \"center\",\n            main.title.size = 0.5,\n            legend.height = 0.5, \n            legend.width = 0.5,\n            legend.text.size = 0.5,\n            legend.title.size = 0.5,\n            main.title.fontface = \"bold\",\n            frame = TRUE)\ntmap_arrange(wp_functional,wp_nonfunctional,pct_functional,pct_nonfunctional, asp=2, ncol=2)\n\n\n\n\n\nwpt_handpump <- qtm(nga_wp, \"wpt handpump\")+\n  tm_layout(main.title = \"Distribution of handpump points\",\n            main.title.position = \"center\",\n            main.title.size = 0.5,\n            legend.height = 0.5, \n            legend.width = 0.5,\n            legend.text.size = 0.5,\n            legend.title.size = 0.5,\n            main.title.fontface = \"bold\",\n            frame = TRUE)\nwpt_mechanizedpump <- qtm(nga_wp, \"wpt mechanizedpump\")+\n  tm_layout(main.title = \"Distribution of mechanizedpump points\",\n            main.title.position = \"center\",\n            main.title.size = 0.5,\n            legend.height = 0.5, \n            legend.width = 0.5,\n            legend.text.size = 0.5,\n            legend.title.size = 0.5,\n            main.title.fontface = \"bold\",\n            frame = TRUE)\n\npct_handpump <- qtm(nga_wp, \"pct_handpump\")+\n  tm_layout(main.title = \"Distribution of handpump rate\",\n            main.title.position = \"center\",\n            main.title.size = 0.5,\n            legend.height = 0.5, \n            legend.width = 0.5,\n            legend.text.size = 0.5,\n            legend.title.size = 0.5,\n            main.title.fontface = \"bold\",\n            frame = TRUE)\npct_mechanizedpump <- qtm(nga_wp, \"pct_mechanizedpump\")+\n  tm_layout(main.title = \"Distribution of mechanizedpump rate\",\n            main.title.position = \"center\",\n            main.title.size = 0.5,\n            legend.height = 0.5, \n            legend.width = 0.5,\n            legend.text.size = 0.5,\n            legend.title.size = 0.5,\n            main.title.fontface = \"bold\",\n            frame = TRUE)\n\ntmap_arrange( wpt_handpump, wpt_mechanizedpump,pct_handpump,pct_mechanizedpump, asp=2, ncol=2)\n\n\n\n\n\nwpt_usage_less_1000 <- qtm(nga_wp, \"wpt usage less 1000\")+\n  tm_layout(main.title = \"Distribution of usage capacity less than 1000\",\n            main.title.position = \"center\",\n            main.title.size = 0.5,\n            legend.height = 0.5, \n            legend.width = 0.4,\n            legend.text.size = 0.4,\n            legend.title.size = 0.5,\n            main.title.fontface = \"bold\",\n            frame = TRUE)\n\nwpt_usage_equal_more_1000 <- qtm(nga_wp, \"wpt usage more 1000\")+\n  tm_layout(main.title = \"Distribution of usage capacity equal or greater than 1000\",\n            main.title.position = \"center\",\n            main.title.size = 0.5,\n            legend.height = 0.5, \n            legend.width = 0.4,\n            legend.text.size = 0.4,\n            legend.title.size = 0.5,\n            main.title.fontface = \"bold\",\n            frame = TRUE)\n\npct_usage_less_1000 <- qtm(nga_wp, \"pct_usage_less_1000\")+\n  tm_layout(main.title = \"Distribution of Percentage of usage capacity less than 1000\",\n            main.title.position = \"center\",\n            main.title.size = 0.5,\n            legend.height = 0.5, \n            legend.width = 0.4,\n            legend.text.size = 0.4,\n            legend.title.size = 0.5,\n            main.title.fontface = \"bold\",\n            frame = TRUE)\npct_usage_equal_more_1000 <- qtm(nga_wp, \"pct_usage_more_1000\")+\n  tm_layout(main.title = \"Distribution of Percentage of usage capacity equal or greater than 1000\",\n            main.title.position = \"center\",\n            main.title.size = 0.5,\n            legend.height = 0.5, \n            legend.width = 0.4,\n            legend.text.size = 0.4,\n            legend.title.size = 0.5,\n            main.title.fontface = \"bold\",\n            frame = TRUE)\n\ntmap_arrange(wpt_usage_less_1000,wpt_usage_equal_more_1000, pct_usage_less_1000,pct_usage_equal_more_1000,asp=2, ncol=2)\n\n\n\n\n\nwpt_rural <- qtm(nga_wp, \"wpt rural\")+\n  tm_layout(main.title = \"Distribution of rural water points\",\n            main.title.position = \"center\",\n            main.title.size = 0.5,\n            legend.height = 0.5, \n            legend.width = 0.4,\n            legend.text.size = 0.4,\n            legend.title.size = 0.5,\n            main.title.fontface = \"bold\",\n            frame = TRUE)\n\npct_rural <- qtm(nga_wp, \"pct_rural\")+\n  tm_layout(main.title = \"Distribution of Percentage of rural water points\",\n            main.title.position = \"center\",\n            main.title.size = 0.5,\n            legend.height = 0.5, \n            legend.width = 0.4,\n            legend.text.size = 0.4,\n            legend.title.size = 0.5,\n            main.title.fontface = \"bold\",\n            frame = TRUE)\ntmap_arrange(wpt_rural,pct_rural, asp=1, ncol=2)\n\n\n\n\n\ntmap_arrange(pct_functional,pct_handpump,pct_usage_less_1000,pct_rural,asp=2, ncol=2)\n\n\n\n\nWe can see the pct_handpump and pct_usage_less_1000 are showing similar choropleth map, they might be highly correlated. We will do Correlation Analysis at later part."
  },
  {
    "objectID": "Take-home Exercise/Take-home_Ex2/Take-home_Ex2.html#data-standardisation",
    "href": "Take-home Exercise/Take-home_Ex2/Take-home_Ex2.html#data-standardisation",
    "title": "ISSS624",
    "section": "7.2 Data Standardisation",
    "text": "7.2 Data Standardisation\n\n7.2.1 Min-Max standardisation\nIn general, multiple variables will be used in cluster analysis. It is not unusual their values range are different. In order to avoid the cluster analysis result is baised to clustering variables with large values, it is useful to standardise the input variables before performing cluster analysis. In this study, we know wpt functional and wpt non-funtional are water points count, however, the other variables are in percentage (ranging from 0 to 1). Hence, will normalize wpt functional and wpt non-funtiona.\n\ncluster_vars.std <- normalize(cluster_vars,c(1:2))\nsummary(cluster_vars.std)\n\n wpt functional    wpt non-functional pct_functional   pct_non-functional\n Min.   :0.00000   Min.   :0.00000    Min.   :0.0000   Min.   :0.0000    \n 1st Qu.:0.02261   1st Qu.:0.04406    1st Qu.:0.3261   1st Qu.:0.2105    \n Median :0.06051   Median :0.12230    Median :0.4741   Median :0.3505    \n Mean   :0.08957   Mean   :0.14962    Mean   :0.4984   Mean   :0.3592    \n 3rd Qu.:0.11669   3rd Qu.:0.21853    3rd Qu.:0.6699   3rd Qu.:0.5076    \n Max.   :1.00000   Max.   :1.00000    Max.   :1.0000   Max.   :1.0000    \n  pct_handpump    pct_mechanizedpump   pct_rural     \n Min.   :0.0000   Min.   :0.0000     Min.   :0.0000  \n 1st Qu.:0.1670   1st Qu.:0.1220     1st Qu.:0.5727  \n Median :0.5099   Median :0.3127     Median :0.8645  \n Mean   :0.4873   Mean   :0.3754     Mean   :0.7271  \n 3rd Qu.:0.7778   3rd Qu.:0.5771     3rd Qu.:1.0000  \n Max.   :1.0000   Max.   :1.0000     Max.   :1.0000"
  },
  {
    "objectID": "Take-home Exercise/Take-home_Ex2/Take-home_Ex2.html#visualising-the-standardised-clustering-variables",
    "href": "Take-home Exercise/Take-home_Ex2/Take-home_Ex2.html#visualising-the-standardised-clustering-variables",
    "title": "ISSS624",
    "section": "7.3 Visualising the standardised clustering variables",
    "text": "7.3 Visualising the standardised clustering variables\n\nr1 <-ggplot(data=cluster_vars, \n             aes(x= `wpt functional`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\") +\n  ggtitle(\"Raw values without standardisation\")\n\nnga_wp_s <- as.data.frame(cluster_vars.std)\ns1 <- ggplot(data=nga_wp_s, \n       aes(x=`wpt functional`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\") +\n  ggtitle(\"Min-Max Standardisation\")\n\nr2 <-ggplot(data=cluster_vars, \n             aes(x= `wpt non-functional`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\") +\n  ggtitle(\"Raw values without standardisation\")\n\nnga_wp_s <- as.data.frame(cluster_vars.std)\ns2 <- ggplot(data=nga_wp_s, \n       aes(x=`wpt non-functional`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\") +\n  ggtitle(\"Min-Max Standardisation\")\n\nggarrange(r1, s1, r2, s2, ncol = 2, nrow = 2)"
  },
  {
    "objectID": "Take-home Exercise/Take-home_Ex2/Take-home_Ex2.html#computing-proximity-matrix",
    "href": "Take-home Exercise/Take-home_Ex2/Take-home_Ex2.html#computing-proximity-matrix",
    "title": "ISSS624",
    "section": "7.4 Computing proximity matrix",
    "text": "7.4 Computing proximity matrix\nThe code chunk below is used to compute the proximity matrix using euclidean method.\n\nproxmat <- dist(cluster_vars.std, method = 'euclidean')\n\nThe code chunk below can then be used to list the content of proxmat for visual inspection.\n\n#proxmat"
  },
  {
    "objectID": "Take-home Exercise/Take-home_Ex2/Take-home_Ex2.html#computing-hierarchical-clustering",
    "href": "Take-home Exercise/Take-home_Ex2/Take-home_Ex2.html#computing-hierarchical-clustering",
    "title": "ISSS624",
    "section": "7.5 Computing hierarchical clustering",
    "text": "7.5 Computing hierarchical clustering\nIn R, there are several packages provide hierarchical clustering function. In this study, hclust() of R stats will be used. The code chunk below performs hierarchical cluster analysis using ward.D method. The hierarchical clustering output is stored in an object of class hclust which describes the tree produced by the clustering process.\n\nhclust_ward <- hclust(proxmat, method = 'ward.D')\n\nWe can then plot the tree by using plot() of R Graphics as shown in the code chunk below.\n\nplot(hclust_ward, cex = 0.6)"
  },
  {
    "objectID": "Take-home Exercise/Take-home_Ex2/Take-home_Ex2.html#selecting-the-optimal-clustering-algorithm",
    "href": "Take-home Exercise/Take-home_Ex2/Take-home_Ex2.html#selecting-the-optimal-clustering-algorithm",
    "title": "ISSS624",
    "section": "7.6 Selecting the optimal clustering algorithm",
    "text": "7.6 Selecting the optimal clustering algorithm\nThe code chunk below will be used to compute the agglomerative coefficients of all hierarchical clustering algorithms.\n\nm <- c( \"average\", \"single\", \"complete\", \"ward\")\nnames(m) <- c( \"average\", \"single\", \"complete\", \"ward\")\n\nac <- function(x) {\n  agnes(cluster_vars, method = x)$ac\n}\n\nmap_dbl(m, ac)\n\n  average    single  complete      ward \n0.9922379 0.9699185 0.9935874 0.9980849 \n\n\nWith reference to the output above, we can see that Ward’s method provides the strongest clustering structure among the four methods assessed. Hence, in the subsequent analysis, only Ward’s method will be used."
  },
  {
    "objectID": "Take-home Exercise/Take-home_Ex2/Take-home_Ex2.html#determining-optimal-clusters",
    "href": "Take-home Exercise/Take-home_Ex2/Take-home_Ex2.html#determining-optimal-clusters",
    "title": "ISSS624",
    "section": "7.7 Determining Optimal Clusters",
    "text": "7.7 Determining Optimal Clusters\nAnother technical challenge face by data analyst in performing clustering analysis is to determine the optimal clusters to retain.\nThere are three commonly used methods to determine the optimal clusters, they are:\nElbow Method Average Silhouette Method Gap Statistic Method\n\n7.7.1 Gap Statistic Method\nTo compute the gap statistic, clusGap() of cluster package will be used.\n\nset.seed(12345)\ngap_stat <- clusGap(cluster_vars, \n                    FUN = hcut, \n                    nstart = 25, \n                    K.max = 10, \n                    B = 50)\n# Print the result\nprint(gap_stat, method = \"firstmax\")\n\nClustering Gap statistic [\"clusGap\"] from call:\nclusGap(x = cluster_vars, FUNcluster = hcut, K.max = 10, B = 50, nstart = 25)\nB=50 simulated reference sets, k = 1..10; spaceH0=\"scaledPCA\"\n --> Number of clusters (method 'firstmax'): 1\n          logW    E.logW       gap     SE.sim\n [1,] 9.759053 10.929018 1.1699647 0.01575131\n [2,] 9.530880 10.464408 0.9335275 0.03632047\n [3,] 9.233786 10.251556 1.0177708 0.02517793\n [4,] 9.174736 10.129729 0.9549933 0.01857290\n [5,] 8.979760 10.031055 1.0512947 0.01773757\n [6,] 8.904310  9.937855 1.0335447 0.01797876\n [7,] 8.874972  9.850697 0.9757256 0.01844868\n [8,] 8.818450  9.773178 0.9547276 0.02116854\n [9,] 8.731570  9.705220 0.9736497 0.01893452\n[10,] 8.675465  9.646105 0.9706394 0.01694845\n\n\nAlso note that the hcut function used is from factoextra package.\nNext, we can visualise the plot by using fviz_gap_stat() of factoextra package.\n\nfviz_gap_stat(gap_stat)\n\n\n\n\nWith reference to the gap statistic graph above, the recommended number of cluster to retain is 1. However, it is not logical to retain only one cluster. By examine the gap statistic graph, the 5-cluster gives the largest gap statistic and should be the next best cluster to pick."
  },
  {
    "objectID": "Take-home Exercise/Take-home_Ex2/Take-home_Ex2.html#interpreting-the-dendrograms",
    "href": "Take-home Exercise/Take-home_Ex2/Take-home_Ex2.html#interpreting-the-dendrograms",
    "title": "ISSS624",
    "section": "7.8 Interpreting the dendrograms",
    "text": "7.8 Interpreting the dendrograms\nIt’s also possible to draw the dendrogram with a border around the selected clusters by using rect.hclust() of R stats. The argument border is used to specify the border colors for the rectangles.\n\nplot(hclust_ward, cex = 0.5)\nrect.hclust(hclust_ward, \n            k = 5, \n            border = 2:5)"
  },
  {
    "objectID": "Take-home Exercise/Take-home_Ex2/Take-home_Ex2.html#visually-driven-hierarchical-clustering-analysis",
    "href": "Take-home Exercise/Take-home_Ex2/Take-home_Ex2.html#visually-driven-hierarchical-clustering-analysis",
    "title": "ISSS624",
    "section": "7.9 Visually-driven hierarchical clustering analysis",
    "text": "7.9 Visually-driven hierarchical clustering analysis\nIn this study, we will perform visually-driven hiearchical clustering analysis by using heatmaply package.\nWith heatmaply, we are able to build both highly interactive cluster heatmap or static cluster heatmap.\n\n7.9.1 Transforming the data frame into a matrix\nThe code chunk below will be used to transform shan_ict data frame into a data matrix.\n\ncluster_vars_mat <- data.matrix(cluster_vars)\n\n\n\n7.9.2 Plotting interactive cluster heatmap using heatmaply()\nIn the code chunk below, the heatmaply() of heatmaply package is used to build an interactive cluster heatmap.\n\nheatmaply(normalize(cluster_vars),\n          Colv=NA,\n          dist_method = \"euclidean\",\n          hclust_method = \"ward.D\",\n          seriate = \"OLO\",\n          colors = Blues,\n          k_row = 5,\n          margins = c(NA,200,60,NA),\n          fontsize_row = 4,\n          fontsize_col = 5,\n          main=\"Geographic Segmentation of water points by nga LCA\",\n          xlab = \"water point Indicators\",\n          ylab = \"nga LCA\"\n          )"
  },
  {
    "objectID": "Take-home Exercise/Take-home_Ex2/Take-home_Ex2.html#mapping-the-clusters-formed",
    "href": "Take-home Exercise/Take-home_Ex2/Take-home_Ex2.html#mapping-the-clusters-formed",
    "title": "ISSS624",
    "section": "7.10 Mapping the clusters formed",
    "text": "7.10 Mapping the clusters formed\nWith closed examination of the dendragram above, we have decided to retain 5 clusters.\ncutree() of R Base will be used in the code chunk below to derive a 5-cluster model.\n\ngroups <- as.factor(cutree(hclust_ward, k=5))\n\nThe code chunk below form the join in three steps:\nthe groups list object will be converted into a matrix; cbind() is used to append groups matrix onto nga_wp to produce an output simple feature object called nga_wp_cluster; and rename of dplyr package is used to rename as.matrix.groups field as CLUSTER.\n\nnga_wp_cluster <- cbind(nga_wp, as.matrix(groups)) %>%\n  rename(`HCLUSTER`=`as.matrix.groups.`)\n\nNext, qtm() of tmap package is used to plot the choropleth map showing the cluster formed.\n\nqtm(nga_wp_cluster, \"HCLUSTER\")"
  },
  {
    "objectID": "Take-home Exercise/Take-home_Ex2/Take-home_Ex2.html#visual-interpretation-of-clusters",
    "href": "Take-home Exercise/Take-home_Ex2/Take-home_Ex2.html#visual-interpretation-of-clusters",
    "title": "ISSS624",
    "section": "7.11 Visual Interpretation of Clusters",
    "text": "7.11 Visual Interpretation of Clusters\nPast studies shown that parallel coordinate plot can be used to reveal clustering variables by cluster very effectively. In the code chunk below, ggparcoord() of GGally package\n\nggparcoord(data = nga_wp_cluster,\n           columns = c(2:8),\n           scale = \"std\",\n           alphaLines = 0.1,\n           boxplot = TRUE,\n           title = \"Multiple Parallel Coordinates Plots of Hierarchical variables by Cluster\") +\n  facet_grid(~ `HCLUSTER`) + \n  theme(\n    plot.title = element_text(size=10),\n    axis.text.x = element_text(size = 6)\n  ) +\n  theme(axis.text.x = element_text(angle = 90))\n\n\n\n\nThe parallel coordinate plot above reveals that in Cluster 2&3, it tends to have higher non-functional water points and rate compared to functional water points and rate at rural area, which might be a concern."
  },
  {
    "objectID": "Take-home Exercise/Take-home_Ex2/Take-home_Ex2.html#converting-into-spatialpolygonsdataframe",
    "href": "Take-home Exercise/Take-home_Ex2/Take-home_Ex2.html#converting-into-spatialpolygonsdataframe",
    "title": "ISSS624",
    "section": "8.1 Converting into SpatialPolygonsDataFrame",
    "text": "8.1 Converting into SpatialPolygonsDataFrame\nThe code chunk below uses as_Spatial() of sf package to convert nga_wp into a SpatialPolygonDataFrame called nga_wp_sp.\n\nnga_wp_sp <- as_Spatial(nga_wp)"
  },
  {
    "objectID": "Take-home Exercise/Take-home_Ex2/Take-home_Ex2.html#computing-neighbour-list",
    "href": "Take-home Exercise/Take-home_Ex2/Take-home_Ex2.html#computing-neighbour-list",
    "title": "ISSS624",
    "section": "8.2 Computing Neighbour List",
    "text": "8.2 Computing Neighbour List\nNext, poly2nd() of spdep package will be used to compute the neighbours list from polygon list.\n\nnga_wp.nb <- poly2nb(nga_wp_sp)\nsummary(nga_wp.nb)\n\nNeighbour list object:\nNumber of regions: 774 \nNumber of nonzero links: 4440 \nPercentage nonzero weights: 0.7411414 \nAverage number of links: 5.736434 \n1 region with no links:\n86\nLink number distribution:\n\n  0   1   2   3   4   5   6   7   8   9  10  11  12  14 \n  1   2  14  57 125 182 140 122  72  41  12   4   1   1 \n2 least connected regions:\n138 560 with 1 link\n1 most connected region:\n508 with 14 links\n\n\nWe notice that index 86 have no neighbor.\nWe will show the neighbor of indext 86. The value is 0 which indicates no neighbor.\n\nnga_wp.nb[[86]]\n\n[1] 0\n\n\nWe will remove index 86.\n\nnga_wp_sp <- nga_wp_sp [-86,]\nnga_wp_sp\n\nclass       : SpatialPolygonsDataFrame \nfeatures    : 773 \nextent      : 28879.72, 1343798, 30292.37, 1094244  (xmin, xmax, ymin, ymax)\ncrs         : +proj=tmerc +lat_0=4 +lon_0=4.5 +k=0.99975 +x_0=230738.26 +y_0=0 +a=6378249.145 +rf=293.465 +towgs84=-92,-93,122,0,0,0,0 +units=m +no_defs \nvariables   : 8\nnames       : shapeName, wpt.functional, wpt.non.functional, pct_functional, pct_non.functional, pct_handpump, pct_mechanizedpump, pct_rural \nmin values  : Aba North,              0,                  0,              0,                  0,            0,                  0,         0 \nmax values  :      Zuru,            752,                278,              1,                  1,            1,                  1,         1 \n\n\nWe willre-compute the neighbours list from polygon list.\n\nnga_wp.nb <- poly2nb(nga_wp_sp)\nsummary(nga_wp.nb)\n\nNeighbour list object:\nNumber of regions: 773 \nNumber of nonzero links: 4440 \nPercentage nonzero weights: 0.7430602 \nAverage number of links: 5.743855 \nLink number distribution:\n\n  1   2   3   4   5   6   7   8   9  10  11  12  14 \n  2  14  57 125 182 140 122  72  41  12   4   1   1 \n2 least connected regions:\n138 560 with 1 link\n1 most connected region:\n508 with 14 links\n\n\nWe can plot the neighbours list on nga_wp_sp by using the code chunk below.\n\n#|fig.width = 15\nplot(nga_wp_sp, \n     border=grey(.5))\nplot(nga_wp.nb, \n    coordinates(nga_wp_sp), \n     col=\"blue\", \n     add=TRUE)"
  },
  {
    "objectID": "Take-home Exercise/Take-home_Ex2/Take-home_Ex2.html#computing-minimum-spanning-tree",
    "href": "Take-home Exercise/Take-home_Ex2/Take-home_Ex2.html#computing-minimum-spanning-tree",
    "title": "ISSS624",
    "section": "8.3 Computing minimum spanning tree",
    "text": "8.3 Computing minimum spanning tree\n\n8.3.1 Calculating edge costs\nNext, nbcosts() of spdep package is used to compute the cost of each edge. It is the distance between it nodes. This function compute this distance using a data.frame with observations vector in each node.\nThe code chunk below is used to compute the cost of each edge.\n\nlcosts <- nbcosts(nga_wp.nb, cluster_vars.std)\n\nNext, We will incorporate these costs into a weights object in the same way as we did in the calculation of inverse of distance weights. In other words, we convert the neighbour list to a list weights object by specifying the just computed lcosts as the weights.\nIn order to achieve this, nb2listw() of spdep package is used as shown in the code chunk below.\nNote that we specify the style as B to make sure the cost values are not row-standardised.\n\nnga_wp.w <- nb2listw(nga_wp.nb, \n                   lcosts, \n                   style=\"B\")\nsummary(nga_wp.w)\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 773 \nNumber of nonzero links: 4440 \nPercentage nonzero weights: 0.7430602 \nAverage number of links: 5.743855 \nLink number distribution:\n\n  1   2   3   4   5   6   7   8   9  10  11  12  14 \n  2  14  57 125 182 140 122  72  41  12   4   1   1 \n2 least connected regions:\n138 560 with 1 link\n1 most connected region:\n508 with 14 links\n\nWeights style: B \nWeights constants summary:\n    n     nn       S0       S1       S2\nB 773 597529 3568.961 6896.949 79290.84"
  },
  {
    "objectID": "Take-home Exercise/Take-home_Ex2/Take-home_Ex2.html#computing-minimum-spanning-tree-1",
    "href": "Take-home Exercise/Take-home_Ex2/Take-home_Ex2.html#computing-minimum-spanning-tree-1",
    "title": "ISSS624",
    "section": "8.4 Computing minimum spanning tree",
    "text": "8.4 Computing minimum spanning tree\nThe minimum spanning tree is computed by mean of the mstree() of spdep package as shown in the code chunk below.\n\nnga_wp.mst <- mstree(nga_wp.w)\n\nAfter computing the MST, we can check its class and dimension by using the code chunk below.\n\nclass(nga_wp.mst)\n\n[1] \"mst\"    \"matrix\"\n\ndim(nga_wp.mst)\n\n[1] 772   3\n\n\nWe can display the content of shan.mst by using head() as shown in the code chunk below.\n\nhead(nga_wp.mst)\n\n     [,1] [,2]      [,3]\n[1,]  451  235 0.1587856\n[2,]  451   89 0.2745670\n[3,]   89  236 0.2830559\n[4,]  236   63 0.1086167\n[5,]  236  415 0.2726844\n[6,]  415   50 0.2684489\n\n\nThe plot method for the MST include a way to show the observation numbers of the nodes in addition to the edge. As before, we plot this together with the nga_wp boundaries. We can see how the initial neighbour list is simplified to just one edge connecting each of the nodes, while passing through all the nodes.\n\nplot(nga_wp_sp, border=gray(.5))\nplot.mst(nga_wp.mst, \n         coordinates(nga_wp_sp), \n         col=\"blue\", \n         cex.lab=0.7, \n         cex.circles=0.005, \n         add=TRUE)"
  },
  {
    "objectID": "Take-home Exercise/Take-home_Ex2/Take-home_Ex2.html#computing-spatially-constrained-clusters-using-skater-method",
    "href": "Take-home Exercise/Take-home_Ex2/Take-home_Ex2.html#computing-spatially-constrained-clusters-using-skater-method",
    "title": "ISSS624",
    "section": "8.5 Computing spatially constrained clusters using SKATER method",
    "text": "8.5 Computing spatially constrained clusters using SKATER method\nThe code chunk below compute the spatially constrained cluster using skater() of spdep package.\n\nclust5 <- spdep::skater(edges = nga_wp.mst[,1:2], \n                 data = cluster_vars, \n                 method = \"euclidean\", \n                 ncuts = 4)\n\nThe skater() takes three mandatory arguments: - the first two columns of the MST matrix (i.e. not the cost), - the data matrix (to update the costs as units are being grouped), and - the number of cuts. Note: It is set to one less than the number of clusters. So, the value specified is not the number of clusters, but the number of cuts in the graph, one less than the number of clusters.\nThe result of the skater() is an object of class skater. We can examine its contents by using the code chunk below.\n\nstr(clust5)\n\nList of 8\n $ groups      : num [1:773] 2 2 1 1 2 2 1 1 2 2 ...\n $ edges.groups:List of 5\n  ..$ :List of 3\n  .. ..$ node: num [1:533] 257 85 655 500 708 695 39 486 256 546 ...\n  .. ..$ edge: num [1:532, 1:3] 85 655 500 708 256 695 414 39 556 266 ...\n  .. ..$ ssw : num 35389\n  ..$ :List of 3\n  .. ..$ node: num [1:234] 31 210 209 197 198 57 321 521 58 522 ...\n  .. ..$ edge: num [1:233, 1:3] 103 34 504 719 718 616 287 329 120 6 ...\n  .. ..$ ssw : num 10138\n  ..$ :List of 3\n  .. ..$ node: num 81\n  .. ..$ edge: num[0 , 1:3] \n  .. ..$ ssw : num 0\n  ..$ :List of 3\n  .. ..$ node: num 110\n  .. ..$ edge: num[0 , 1:3] \n  .. ..$ ssw : num 0\n  ..$ :List of 3\n  .. ..$ node: num [1:4] 83 382 229 413\n  .. ..$ edge: num [1:3, 1:3] 382 83 83 229 413 ...\n  .. ..$ ssw : num 297\n $ not.prune   : NULL\n $ candidates  : int [1:5] 1 2 3 4 5\n $ ssto        : num 49580\n $ ssw         : num [1:5] 49580 48057 47200 46482 45824\n $ crit        : num [1:2] 1 Inf\n $ vec.crit    : num [1:773] 1 1 1 1 1 1 1 1 1 1 ...\n - attr(*, \"class\")= chr \"skater\"\n\n\nWe can check the cluster assignment by using the conde chunk below. We can find out how many observations are in each cluster by means of the table command.\n\nccs5 <- clust5$groups\nccs5\n\n  [1] 2 2 1 1 2 2 1 1 2 2 2 1 2 2 1 1 1 2 2 1 1 1 2 1 2 2 2 1 1 1 2 1 1 2 1 1 2\n [38] 1 1 2 1 2 2 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 1 1 1 1 1 1 1 2 1 2 1 1 1 1 1 1\n [75] 1 1 2 2 2 2 3 1 5 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 1 1 1 1 1 1 4 1\n[112] 1 1 1 1 1 2 1 1 2 2 1 1 1 2 1 1 1 1 1 1 2 2 1 2 2 1 1 1 1 1 1 1 1 1 1 1 1\n[149] 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 2 1 1 1 2 2 1 1 1 1 1 1 1 1 1 1 2 1 2 2 1 1\n[186] 1 1 2 2 2 1 2 2 2 1 2 2 2 2 1 2 2 2 2 2 1 2 2 2 2 2 2 1 2 2 2 2 1 1 1 1 1\n[223] 1 1 1 1 1 1 5 1 1 1 1 1 1 1 1 1 2 1 1 1 1 1 2 1 1 1 1 1 1 1 2 1 1 1 1 1 1\n[260] 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1 2 1 1 1 1 2 2 1 2 2 1 2 2 2 2 1 1 1\n[297] 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 1 1 1 1 1 1 2 2 2 1 2 1 1 1 1 2 2 1 2 2\n[334] 2 2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 1 2 1 2 2\n[371] 2 1 1 2 2 1 1 2 1 1 1 5 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\n[408] 1 1 1 1 1 5 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 2 1 2 1 1 1 1\n[445] 1 1 1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\n[482] 1 2 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1\n[519] 1 1 2 2 2 1 1 1 2 1 1 2 2 2 2 2 2 2 2 2 2 2 1 2 1 2 2 1 2 2 1 2 2 2 2 1 1\n[556] 1 1 2 1 1 2 2 2 2 1 1 1 2 2 2 1 2 2 2 2 2 2 2 1 2 1 1 2 2 1 2 2 2 2 1 2 1\n[593] 1 1 1 2 1 1 1 2 2 2 2 2 1 1 1 1 1 2 1 2 2 2 2 2 2 2 1 2 2 1 2 1 2 1 1 2 2\n[630] 2 2 2 1 1 2 2 1 1 1 1 1 2 1 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 1 1 1 1\n[667] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 2\n[704] 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 1 2 1 2 2 2 2 2 2 1 2 2 2 2 1 2 2 2 2 1\n[741] 1 1 1 1 2 2 1 1 1 1 1 1 1 1 1 2 2 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1 1\n\ntable(ccs5)\n\nccs5\n  1   2   3   4   5 \n533 234   1   1   4 \n\n\nLastly, we can also plot the pruned tree that shows the four clusters on top of the nga_wp area.\n\nplot(nga_wp_sp, border=gray(.5))\nplot(clust5, \n     coordinates(nga_wp_sp), \n     cex.lab=.7,\n     groups.colors=c(\"red\",\"green\",\"blue\", \"brown\", \"pink\"),\n     cex.circles=0.005, \n     add=TRUE)\n\nWarning in segments(coords[id1, 1], coords[id1, 2], coords[id2, 1],\ncoords[id2, : \"add\" is not a graphical parameter\n\nWarning in segments(coords[id1, 1], coords[id1, 2], coords[id2, 1],\ncoords[id2, : \"add\" is not a graphical parameter\n\nWarning in segments(coords[id1, 1], coords[id1, 2], coords[id2, 1],\ncoords[id2, : \"add\" is not a graphical parameter"
  },
  {
    "objectID": "Take-home Exercise/Take-home_Ex2/Take-home_Ex2.html#visualising-the-clusters-in-choropleth-map",
    "href": "Take-home Exercise/Take-home_Ex2/Take-home_Ex2.html#visualising-the-clusters-in-choropleth-map",
    "title": "ISSS624",
    "section": "8.6 Visualising the clusters in choropleth map",
    "text": "8.6 Visualising the clusters in choropleth map\nThe code chunk below is used to plot the newly derived clusters by using SKATER method.\n\nnga_wp_cluster <- nga_wp_cluster [-86,]\ngroups_mat <- as.matrix(clust5$groups)\nnga_wp_spatialcluster <- cbind(nga_wp_cluster, as.factor(groups_mat)) %>%\n  rename(`SP_CLUSTER`=`as.factor.groups_mat.`)\nqtm(nga_wp_spatialcluster, \"SP_CLUSTER\")\n\n\n\n\nFor easy comparison, it will be better to place both the hierarchical clustering and spatially constrained hierarchical clustering maps next to each other.\n\nhclust.map <- qtm(nga_wp_cluster,\n                  \"HCLUSTER\") + \n  tm_borders(alpha = 0.5) \n\nshclust.map <- qtm(nga_wp_spatialcluster,\n                   \"SP_CLUSTER\") + \n  tm_borders(alpha = 0.5) \n\ntmap_arrange(hclust.map, shclust.map,\n             asp=1, ncol=2)\n\nWarning: One tm layer group has duplicated layer types, which are omitted. To\ndraw multiple layers of the same type, use multiple layer groups (i.e. specify\ntm_shape prior to each of them).\n\nWarning: One tm layer group has duplicated layer types, which are omitted. To\ndraw multiple layers of the same type, use multiple layer groups (i.e. specify\ntm_shape prior to each of them)."
  },
  {
    "objectID": "Take-home Exercise/Take-home_Ex2/Take-home_Ex2.html#visual-interpretation-of-clusters-1",
    "href": "Take-home Exercise/Take-home_Ex2/Take-home_Ex2.html#visual-interpretation-of-clusters-1",
    "title": "ISSS624",
    "section": "8.7 Visual Interpretation of Clusters",
    "text": "8.7 Visual Interpretation of Clusters\n\nggparcoord(data = nga_wp_spatialcluster,\n           columns = c(2:8),\n           scale = \"std\",\n           alphaLines = 0.1,\n           boxplot = TRUE,\n           title = \"Multiple Parallel Coordinates Plots of SKATER cluster Variables by Cluster\") +\n  facet_grid(~ `SP_CLUSTER`) + theme(\n    plot.title = element_text(size=10),\n    axis.text.x = element_text(size = 6)\n  ) +\n  theme(axis.text.x = element_text(angle = 90))\n\n\n\n\nThe parallel coordinate plot above reveals that in Cluster 2, it tends to have higher non-functional water points and rate compared to functional water points and rate at rural area, which might be a concern."
  },
  {
    "objectID": "Take-home Exercise/Take-home_Ex2/Take-home_Ex2.html#a-short-note-about-clustgeo-package",
    "href": "Take-home Exercise/Take-home_Ex2/Take-home_Ex2.html#a-short-note-about-clustgeo-package",
    "title": "ISSS624",
    "section": "9.1 A short note about ClustGeo package",
    "text": "9.1 A short note about ClustGeo package\nClustGeo package is an R package specially designed to support the need of performing spatially constrained cluster analysis. More specifically, it provides a Ward-like hierarchical clustering algorithm called hclustgeo() including spatial/geographical constraints."
  },
  {
    "objectID": "Take-home Exercise/Take-home_Ex2/Take-home_Ex2.html#ward-like-hierarchical-clustering-clustgeo",
    "href": "Take-home Exercise/Take-home_Ex2/Take-home_Ex2.html#ward-like-hierarchical-clustering-clustgeo",
    "title": "ISSS624",
    "section": "9.2 Ward-like hierarchical clustering: ClustGeo",
    "text": "9.2 Ward-like hierarchical clustering: ClustGeo\nClustGeo package provides function called hclustgeo() to perform a typical Ward-like hierarchical clustering just like hclust() you learned in previous section.\nTo perform non-spatially constrained hierarchical clustering, we only need to provide the function a dissimilarity matrix as shown in the code chunk below.\n\nnongeo_cluster <- hclustgeo(proxmat)\nplot(nongeo_cluster, cex = 0.5)\nrect.hclust(nongeo_cluster, \n            k = 5, \n            border = 2:5)\n\n\n\n\nNote that the dissimilarity matrix must be an object of class dist, i.e. an object obtained with the function dist(). For sample code chunk, please refer to 5.7.6 Computing proximity matrix\n\n9.2.1 Mapping the clusters formed\nSimilarly, we can plot the clusters on a categorical area shaded map by using the steps we learned in 5.7.12 Mapping the clusters formed.\n\ngroups <- as.factor(cutree(nongeo_cluster, k=5))\n\nnga_wp_ngeo_cluster <- cbind(nga_wp, as.matrix(groups)) %>%\n  rename(`NGCLUSTER` = `as.matrix.groups.`)\n\nqtm(nga_wp_ngeo_cluster, \"NGCLUSTER\")"
  },
  {
    "objectID": "Take-home Exercise/Take-home_Ex2/Take-home_Ex2.html#visual-interpretation-of-clusters-2",
    "href": "Take-home Exercise/Take-home_Ex2/Take-home_Ex2.html#visual-interpretation-of-clusters-2",
    "title": "ISSS624",
    "section": "9.3 Visual Interpretation of Clusters",
    "text": "9.3 Visual Interpretation of Clusters"
  },
  {
    "objectID": "Take-home Exercise/Take-home_Ex2/Take-home_Ex2.html#visualising-individual-clustering-variable",
    "href": "Take-home Exercise/Take-home_Ex2/Take-home_Ex2.html#visualising-individual-clustering-variable",
    "title": "ISSS624",
    "section": "9.3.1 Visualising individual clustering variable",
    "text": "9.3.1 Visualising individual clustering variable\nPast studies shown that parallel coordinate plot can be used to reveal clustering variables by cluster very effectively. In the code chunk below, ggparcoord() of GGally package\n\nggparcoord(data = nga_wp_ngeo_cluster,\n           columns = c(2:8),\n           scale = \"std\",\n           alphaLines = 0.1,\n           boxplot = TRUE,\n           title = \"Multiple Parallel Coordinates Plots of non-spatially constrained hierarchical clustering variables by Cluster\") +\n  facet_grid(~ `NGCLUSTER`) + \n  theme(\n    plot.title = element_text(size=10),\n    axis.text.x = element_text(size = 6)\n  ) +\n  theme(axis.text.x = element_text(angle = 90))\n\n\n\n\nThe parallel coordinate plot above reveals that in Cluster 3&4, it tends to have higher non-functional water points and rate compared to functional water points and rate at rural area, which might be a concern."
  },
  {
    "objectID": "Take-home Exercise/Take-home_Ex2/Take-home_Ex2.html#spatially-constrained-hierarchical-clustering-1",
    "href": "Take-home Exercise/Take-home_Ex2/Take-home_Ex2.html#spatially-constrained-hierarchical-clustering-1",
    "title": "ISSS624",
    "section": "9.4 Spatially Constrained Hierarchical Clustering",
    "text": "9.4 Spatially Constrained Hierarchical Clustering\nBefore we can performed spatially constrained hierarchical clustering, a spatial distance matrix will be derived by using st_distance() of sf package.\n\ndist <- st_distance(nga_wp, nga_wp)\ndistmat <- as.dist(dist)\n\nNotice that as.dist() is used to convert the data frame into matrix.\nNext, choicealpha() will be used to determine a suitable value for the mixing parameter alpha as shown in the code chunk below.\n\ncr <- choicealpha(proxmat, distmat, range.alpha = seq(0, 1, 0.1), K=5, graph = TRUE)\n\n\n\n\n\n\n\nWith reference to the graphs above, alpha = 0.4 will be used as shown in the code chunk below.\n\nclustG <- hclustgeo(proxmat, distmat, alpha = 0.4)\n\nNext, cutree() is used to derive the cluster object.\n\ngroups <- as.factor(cutree(clustG, k=5))\n\nWe will then join back the group list with nga_wp polygon feature data frame by using the code chunk below.\n\nnga_wp_Gcluster <- cbind(nga_wp, as.matrix(groups)) %>%\n  rename(`GCLUSTER` = `as.matrix.groups.`)\n\nWe can now plot the map of the newly delineated spatially constrained clusters.\n\nqtm(nga_wp_Gcluster, \"GCLUSTER\")"
  },
  {
    "objectID": "Take-home Exercise/Take-home_Ex2/Take-home_Ex2.html#visual-interpretation-of-clusters-3",
    "href": "Take-home Exercise/Take-home_Ex2/Take-home_Ex2.html#visual-interpretation-of-clusters-3",
    "title": "ISSS624",
    "section": "9.4 Visual Interpretation of Clusters",
    "text": "9.4 Visual Interpretation of Clusters"
  },
  {
    "objectID": "Take-home Exercise/Take-home_Ex2/Take-home_Ex2.html#visualising-individual-clustering-variable-1",
    "href": "Take-home Exercise/Take-home_Ex2/Take-home_Ex2.html#visualising-individual-clustering-variable-1",
    "title": "ISSS624",
    "section": "9.5.1 Visualising individual clustering variable",
    "text": "9.5.1 Visualising individual clustering variable\nPast studies shown that parallel coordinate plot can be used to reveal clustering variables by cluster very effectively. In the code chunk below, ggparcoord() of GGally package\n\nggparcoord(data = nga_wp_Gcluster,\n           columns = c(2:8),\n           scale = \"std\",\n           alphaLines = 0.1,\n           boxplot = TRUE,\n           title = \"Multiple Parallel Coordinates Plots of spatially constrained hierarchical clustering variables by Cluster\") +\n  facet_grid(~ `GCLUSTER`) + \n  theme(\n    plot.title = element_text(size=10),\n    axis.text.x = element_text(size = 6)\n  ) +\n  theme(axis.text.x = element_text(angle = 90))\n\n\n\n\nThe parallel coordinate plot above reveals that in Cluster 3&4, it tends to have higher non-functional water points and rate compared to functional water points and rate at rural area, which might be a concern."
  }
]